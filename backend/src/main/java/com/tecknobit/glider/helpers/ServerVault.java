package com.tecknobit.glider.helpers;

import com.tecknobit.apimanager.apis.APIRequest;
import com.tecknobit.apimanager.apis.encryption.aes.AESServerCipher;
import com.tecknobit.equinoxcore.annotations.FutureEquinoxApi;
import com.tecknobit.equinoxcore.annotations.Wrapper;
import com.tecknobit.glider.services.passwords.entities.Password;
import com.tecknobit.glidercore.enums.PasswordType;
import kotlin.Pair;
import kotlin.Triple;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.security.NoSuchAlgorithmException;
import java.util.List;

import static com.tecknobit.apimanager.apis.APIRequest.SHA256_ALGORITHM;
import static com.tecknobit.apimanager.apis.encryption.BaseCipher.Algorithm.CTR_ALGORITHM;
import static com.tecknobit.apimanager.apis.encryption.aes.AESServerCipher.AESKeySize.k128;
import static com.tecknobit.equinoxbackend.environment.services.builtin.service.EquinoxItemsHelper.COMMA;
import static com.tecknobit.equinoxbackend.resourcesutils.ResourcesManager.RESOURCES_PATH;

/**
 * The {@code ServerVault} class is used to handle the cipher of the password data such tail, scopes and the password
 * value. Each user has his/her own AES key created during the signup request
 *
 * @author N7ghtm4r3 - Tecknobit
 */
@FutureEquinoxApi(
        releaseVersion = "1.2.0",
        protoBehavior = """
                This could be integrated as official standalone api in Equinox, adapting to a general purpose.
                Check to integrate that as well and replace this
                """
)
public class ServerVault {

    /**
     * {@code VAULT_FOLDER} the folder where the vault store the keys
     */
    public static final String VAULT_FOLDER = "vault";

    /**
     * {@code VAULT_PATHNAME} the path name where are store the keys generated by the vault
     */
    private static final String VAULT_PATHNAME = RESOURCES_PATH + VAULT_FOLDER + "/";

    /**
     * {@code INVALID_PATHNAME_CHARACTERS_REGEX} regex used to clear the pathname of the lock box from invalid characters
     */
    private static final String INVALID_PATHNAME_CHARACTERS_REGEX = "[^a-zA-Z0-9._-]";

    /**
     * {@code INVALID_PATHNAME_CHARACTER_REPLACER} character replacer from the invalid characters found by the
     * {@link #INVALID_PATHNAME_CHARACTERS_REGEX}
     */
    private static final String INVALID_PATHNAME_CHARACTER_REPLACER = "a";

    /**
     * {@code vault} the singleton instance of the vault
     */
    private static final ServerVault vault = new ServerVault();

    /**
     * Constructor to instantiate the object
     */
    private ServerVault() {
    }

    /**
     * Method used to create the user's private key
     *
     * @param token The token of the user
     * @throws Exception when an error occurred during the key creation
     */
    public void createUserPrivateKey(String token) throws Exception {
        String secretKey = AESServerCipher.createBase64SecretKey(k128);
        String ivSpec = AESServerCipher.createBase64IvParameterSpec();
        storePrivateKey(token, secretKey, ivSpec);
    }

    /**
     * Method used to store the private key of the user
     *
     * @param token The token of the user
     * @param secretKey The secret key generated
     * @param ivSpec The initialization vector generated
     *
     * @throws Exception when an error occurred during the key creation
     */
    private void storePrivateKey(String token, String secretKey, String ivSpec) throws Exception {
        String lockBoxPathname = computeLockBoxPathName(token);
        try (FileWriter lockBoxWriter = new FileWriter(lockBoxPathname)) {
            lockBoxWriter.write(secretKey);
            lockBoxWriter.write(COMMA);
            lockBoxWriter.write(ivSpec);
        }
    }

    /**
     * Method used to encrypt the data of the password
     *
     * @param token The token of the user
     * @param tail The tail of the password
     * @param password The value of the password
     * @param scopes The related scopes of the password
     *
     * @throws Exception when an error occurred during the encryption
     *
     * @return the data encrypted as {@link Triple} of {@link String}
     */
    public Triple<String, String, String> encryptPasswordData(String token, String tail, String password,
                                                              String scopes) throws Exception {
        AESServerCipher cipher = getCipherInstance(token);
        if (scopes == null)
            scopes = " ";
        String encryptedTail = cipher.encryptBase64(tail);
        String encryptedPassword = cipher.encryptBase64(password);
        String encryptedScopes = cipher.encryptBase64(scopes);
        return new Triple<>(encryptedTail, encryptedPassword, encryptedScopes);
    }

    /**
     * Method used to encrypt the password
     *
     * @param token The token of the user
     * @param password The value of the password
     *
     * @throws Exception when an error occurred during the encryption
     *
     * @return the password encrypted as {@link String}
     */
    public String encryptPassword(String token, String password) throws Exception {
        AESServerCipher cipher = getCipherInstance(token);
        return cipher.encryptBase64(password);
    }

    /**
     * Method used to encrypt the data of the password
     *
     * @param token The token of the user
     * @param tail The tail of the password
     * @param scopes The related scopes of the password
     *
     * @throws Exception when an error occurred during the encryption
     *
     * @return the data encrypted as {@link Pair} of {@link String}
     */
    public Pair<String, String> encryptPasswordData(String token, String tail, String scopes) throws Exception {
        AESServerCipher cipher = getCipherInstance(token);
        if (scopes == null)
            scopes = " ";
        String encryptedTail = cipher.encryptBase64(tail);
        String encryptedScopes = cipher.encryptBase64(scopes);
        return new Pair<>(encryptedTail, encryptedScopes);
    }

    /**
     * Method used to decrypt a list of passwords
     *
     * @param token The token of the user
     * @param passwords The passwords list to decrypt
     *
     * @throws Exception when an error occurred during the decryption
     */
    public void decryptPasswords(String token, List<Password> passwords) throws Exception {
        AESServerCipher decipher = getCipherInstance(token);
        for (Password password : passwords)
            decryptPassword(decipher, password, true);
    }

    /**
     * Method used to decrypt a password
     *
     * @param token The token of the user
     * @param password The password to decrypt
     *
     * @throws Exception when an error occurred during the decryption
     */
    @Wrapper
    public void decryptPassword(String token, Password password) throws Exception {
        decryptPassword(getCipherInstance(token), password, false);
    }

    /**
     * Method used to get the related {@link AESServerCipher} of the user
     *
     * @param token The token of the user
     * @return the instance as {@link AESServerCipher}
     *
     * @throws Exception when an error occurred during the retrieving operation
     */
    private AESServerCipher getCipherInstance(String token) throws Exception {
        Pair<String, String> keySlices = retrievePrivateKey(token);
        return new AESServerCipher(keySlices.getFirst(), keySlices.getSecond(), CTR_ALGORITHM);
    }

    /**
     * Method used to retrieve the user private key
     *
     * @param token The token of the user
     * @return the private key of the user as {@link Pair} of {@link String}
     * @throws Exception when an error occurred during the retrieving operation
     */
    private Pair<String, String> retrievePrivateKey(String token) throws Exception {
        String lockBoxPathname = computeLockBoxPathName(token);
        BufferedReader bufferedReader = new BufferedReader(new FileReader(lockBoxPathname));
        String[] rawData = bufferedReader.readLine().split(COMMA);
        bufferedReader.close();
        return new Pair<>(rawData[0], rawData[1]);
    }

    /**
     * Method used to decrypt a password
     *
     * @param decipher   The instance used to decrypt the password
     * @param password   The password to decrypt
     * @param bypassType Whether bypass the check on the {@link PasswordType}
     * @throws Exception when an error occurred during the decryption
     */
    private void decryptPassword(AESServerCipher decipher, Password password, boolean bypassType) throws Exception {
        String decryptedTail = decipher.decryptBase64(password.getTail());
        String decryptedScopes = decipher.decryptBase64(password.getScopes());
        String decryptedPassword = null;
        if (bypassType || password.getType() == PasswordType.INSERTED)
            decryptedPassword = decipher.decryptBase64(password.getPassword());
        password.setDecryptedData(new Triple<>(decryptedTail, decryptedScopes, decryptedPassword));
    }

    /**
     * Method used to delete the private lock box of the user
     *
     * @param token The token of the user
     *
     * @return whether the lock box has been deleted as {@code boolean}
     */
    public boolean deleteLockBox(String token) {
        String lockBoxPathname;
        try {
            lockBoxPathname = computeLockBoxPathName(token);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        return new File(lockBoxPathname).delete();
    }

    /**
     * Method used to compute the pathname of the lock box of the user
     *
     * @param token The token of the user
     *
     * @return the lock box path name as {@link String}
     *
     * @throws NoSuchAlgorithmException when an error occurred during the decryption
     */
    private String computeLockBoxPathName(String token) throws NoSuchAlgorithmException {
        return VAULT_PATHNAME + APIRequest.base64Digest(token, SHA256_ALGORITHM)
                .replaceAll(INVALID_PATHNAME_CHARACTERS_REGEX, INVALID_PATHNAME_CHARACTER_REPLACER);
    }

    /**
     * Method used to obtain the instance of the vault
     *
     * @return the vault instance as {@link ServerVault}
     */
    public static ServerVault getInstance() {
        return vault;
    }

}
